<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mise à jour ESP32 — Wi-Fi & BLE</title>
<style>
  :root{
    --bg:#f6f7fb; --card:#fff; --text:#222; --muted:#666;
    --primary:#0d6efd; --success:#2ba84a; --danger:#dc3545;
    --border:#e6e8ee;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:680px;margin:40px auto;padding:24px;background:var(--card);
    border-radius:12px;border:1px solid var(--border);box-shadow:0 8px 24px rgba(0,0,0,.05)}
  h1{margin:0 0 8px;font-size:1.6rem}
  p.desc{margin:0 0 20px;color:var(--muted)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .file{flex:1;display:flex;gap:10px;align-items:center}
  input[type="file"]{display:block}
  button{border:0;border-radius:8px;padding:.7rem 1rem;font-weight:600;color:#fff;background:var(--primary);cursor:pointer}
  button.secondary{background:#6c757d}
  button.success{background:var(--success)}
  button.danger{background:var(--danger)}
  button:disabled{opacity:.55;cursor:not-allowed}
  .progress{margin:14px 0;height:16px;background:#e9edf5;border-radius:8px;overflow:hidden}
  .bar{height:100%;width:0%;background:var(--primary);color:#fff;font-size:12px;line-height:16px;text-align:center;transition:width .2s}
  .log{margin-top:16px;background:#fafbff;border:1px solid var(--border);border-radius:8px;padding:10px;min-height:140px;max-height:320px;overflow:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;font-size:13px;white-space:pre-wrap}
  .muted{color:var(--muted);font-size:.9rem}
  .hint{margin-top:6px;color:var(--muted);font-size:.9rem}
  .footer{margin-top:16px;display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}
  .mode{display:flex;gap:8px;align-items:center;margin:8px 0 14px}
  .toggle{border:1px solid var(--border);background:#fff;color:#111;border-radius:999px;padding:.35rem .9rem;cursor:pointer}
  .toggle.active{background:var(--primary);color:#fff;border-color:var(--primary)}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Mise à jour ESP32</h1>
    <p class="desc">1) Uploader <code>firmware.bin</code> vers le FS. 2) Lancer “Mettre à jour l’ESP32”. Choisir Wi-Fi ou BLE.</p>

    <!-- Sélecteur de transport -->
    <div class="mode">
      <button id="mode-wifi" class="toggle active" type="button">Wi-Fi</button>
      <button id="mode-ble" class="toggle" type="button">Bluetooth</button>
      <button id="ble-connect-btn" class="toggle" type="button" style="display:none;">Se connecter en BLE</button>
      <span id="ble-status" class="muted"></span>
    </div>

    <!-- Fichier + upload -->
    <div class="row">
      <div class="file">
        <input id="file" type="file" accept=".bin" />
        <span id="fname" class="muted">Aucun fichier sélectionné</span>
      </div>
      <div class="row" style="gap:8px">
        <button id="btnUpload" type="button" disabled>Téléverser</button>
        <span id="uplabel" class="muted">Prêt.</span>
      </div>
    </div>

    <div class="progress"><div id="bar" class="bar">0%</div></div>

    <!-- Actions -->
    <div class="footer">
      <button id="btnOTA" class="success" type="button" disabled>Mettre à jour l'ESP32</button>
      <button id="btnReload" class="secondary" type="button">Recharger</button>
    </div>

    <div id="log" class="log"></div>
    <div class="hint">
      BLE via navigateur compatible et contexte sécurisé (HTTPS/localhost).  
      OTA: envoi de <code>CMD:APPLY_OTA</code> via le transport sélectionné.
    </div>
  </div>

<script>
/* ========= Helpers ========= */
const logDiv = document.getElementById('log');
function logln(s){ logDiv.textContent += s + '\n'; logDiv.scrollTop = logDiv.scrollHeight; }
function setBar(p){ const v = Math.max(0, Math.min(100, Math.round(p))); bar.style.width = v+'%'; bar.textContent = v+'%'; }

/* ========= DOM refs ========= */
const inpFile   = document.getElementById('file');
const nameSpan  = document.getElementById('fname');
const btnUpload = document.getElementById('btnUpload');
const btnOTA    = document.getElementById('btnOTA');
const btnReload = document.getElementById('btnReload');
const uplabel   = document.getElementById('uplabel');
const bar       = document.getElementById('bar');

const modeWifiBtn   = document.getElementById('mode-wifi');
const modeBleBtn    = document.getElementById('mode-ble');
const bleConnectBtn = document.getElementById('ble-connect-btn');
const bleStatus     = document.getElementById('ble-status');

let transport = 'wifi';

/* ========= Feature detection BLE ========= */
function isSecureContextOk(){
  if (location.protocol === 'https:') return true;
  if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') return true;
  return false;
}
function isWebBluetoothAvailable(){ return !!(navigator && navigator.bluetooth); }
function configureBleAvailability(){
  if (!isWebBluetoothAvailable()) {
    modeBleBtn.style.display = 'none';
    bleConnectBtn.style.display = 'none';
    bleStatus.textContent = 'BLE non supporté par ce navigateur';
    return;
  }
  if (!isSecureContextOk()) {
    bleStatus.textContent = 'Contexte non sécurisé (HTTPS requis pour BLE)';
  }
}

/* ========= Wi-Fi (WS + HTTP) ========= */
let ws = null;
function wsConnect(){
  try {
    ws = new WebSocket(`ws://${window.location.hostname}/ws`);
    ws.onopen    = () => logln('> WS: connecté');
    ws.onmessage = (ev) => handleDeviceMessage(String(ev.data || ''));
    ws.onclose   = () => logln('> WS: déconnecté');
    ws.onerror   = () => logln('> WS: erreur');
  } catch(e){ logln('> WS: exception ' + e); }
}
function sendOverWifi(cmd){
  if (!ws || ws.readyState !== 1){ logln('✖ WebSocket non connecté.'); return; }
  ws.send(cmd);
}

/* ========= BLE ========= */
const FW_SERVICE_UUID = 'd3a8f820-9b39-4a7c-9d09-7b5e5a313001';
const CTRL_CHAR_UUID  = 'd3a8f821-9b39-4a7c-9d09-7b5e5a313001';
const DATA_CHAR_UUID  = 'd3a8f822-9b39-4a7c-9d09-7b5e5a313001';
const NOTIF_CHAR_UUID = 'd3a8f823-9b39-4a7c-9d09-7b5e5a313001';
let ble = { device:null, server:null, ctrl:null, data:null, notif:null };

async function bleConnect(){
  if (!isWebBluetoothAvailable()){ bleStatus.textContent = 'BLE non supporté'; return; }
  if (!isSecureContextOk()){ bleStatus.textContent = 'HTTPS requis pour le BLE'; return; }
  try {
    bleStatus.textContent = 'scan...';
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'ESP32-Uploader' }],
      optionalServices: [FW_SERVICE_UUID]
    });
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(FW_SERVICE_UUID);
    const ctrl = await service.getCharacteristic(CTRL_CHAR_UUID);
    const data = await service.getCharacteristic(DATA_CHAR_UUID);
    const notif = await service.getCharacteristic(NOTIF_CHAR_UUID);
    await notif.startNotifications();
    notif.addEventListener('characteristicvaluechanged', (e) => {
      const msg = new TextDecoder().decode(e.target.value);
      handleDeviceMessage(msg);
    });
    ble = { device, server, ctrl, data, notif };
    bleStatus.textContent = 'connecté';
    logln('✔ BLE connecté.');
  } catch(e){
    bleStatus.textContent = 'échec';
    logln('✖ BLE: ' + e);
  }
}
async function sendOverBle(cmd){
  if (!ble.ctrl){ logln('✖ BLE non connecté.'); return; }
  await ble.ctrl.writeValue(new TextEncoder().encode(cmd));
}

/* ========= Transport selection ========= */
function setMode(m){
  if (m !== 'wifi' && m !== 'ble') return;
  transport = m;
  modeWifiBtn.classList.toggle('active', m==='wifi');
  modeBleBtn.classList.toggle('active', m==='ble');
  bleConnectBtn.style.display = (m==='ble') ? '' : 'none';
  if (m === 'wifi' && (!ws || ws.readyState !== 1)) wsConnect();
  logln('> Mode ' + m.toUpperCase() + ' sélectionné.');
}
modeWifiBtn.addEventListener('click', () => setMode('wifi'));
modeBleBtn.addEventListener('click', () => setMode('ble'));
bleConnectBtn.addEventListener('click', bleConnect);

/* ========= Upload/OTA state ========= */
let uploading = false;
let lastUploadPct = -1;
let otaSent = false;
let lastOtaSeq = -1;
let lastOtaPct = -1;

function setUploadProgress(p){
  const v = Math.max(0, Math.min(100, Math.round(p)));
  if (v >= lastUploadPct) {
    lastUploadPct = v;
    setBar(v);
  }
}
function resetUploadProgress(){
  uploading = false;
  lastUploadPct = -1;
}

/* ========= Device messages (logs) ========= */
function handleDeviceMessage(message){
  // OTA progression stricte: "OTA_PROGRESS <seq> <pct>"
  const mStrict = message.match(/^OTA_PROGRESS\s+(\d+)\s+(\d+)\s*$/);
  if (mStrict){
    const seq = parseInt(mStrict[1], 10);
    const pct = parseInt(mStrict[2], 10);
    if (seq > lastOtaSeq && pct >= lastOtaPct){
      lastOtaSeq = seq; lastOtaPct = pct;
      setBar(pct);
      uplabel.textContent = (pct < 100 ? 'Mise à jour en cours...' : 'OTA terminé, redémarrage…');
    }
    logln(message);
    return;
  }

  // Compat OTA: "OTA en cours: X%"
  const mLegacy = message.match(/OTA en cours:\s*(\d+)%\s*$/i);
  if (mLegacy){
    const pct = parseInt(mLegacy[1],10);
    if (pct >= lastOtaPct) { lastOtaPct = pct; setBar(pct); }
    uplabel.textContent = (pct < 100 ? 'Mise à jour en cours...' : 'OTA terminé, redémarrage…');
    logln(message);
    return;
  }

  // Progression upload reportée par le device
  const mUp = message.match(/Téléversement en cours:\s*(\d+)\s*%?/i);
  if (mUp){
    // Si upload en cours ET transport BLE, on suit le device
    if (uploading && transport === 'ble') {
      const p = parseInt(mUp[1], 10);
      if (!Number.isNaN(p) && p >= lastUploadPct) {
        lastUploadPct = p;
        setBar(p);
        uplabel.textContent = 'Téléversement en cours...';
      }
    }
    logln(message);
    return;
  }

  // Upload terminé (événement device)
  if (/EVENT:UPLOAD_COMPLETE/i.test(message)){
    setUploadProgress(100);
    resetUploadProgress();
    uplabel.textContent = 'Upload terminé. Prêt pour OTA.';
    btnOTA.disabled = false;
    logln(message);
    return;
  }

  logln(message);
}

/* ========= Uploads ========= */
// Wi-Fi: POST "/" champ "firmware"
function uploadOverWifi(file){
  return new Promise((resolve, reject)=>{
    const xhr = new XMLHttpRequest();
    xhr.open('POST', '/', true);
    uploading = true; lastUploadPct = -1; setBar(0); uplabel.textContent = 'Téléversement en cours...';

    xhr.upload.onprogress = (e)=>{
      if (e.lengthComputable) setUploadProgress((e.loaded / e.total) * 100);
    };
    xhr.onload = ()=>{
      resetUploadProgress();
      (xhr.status === 200 ? resolve() : reject(new Error('HTTP '+xhr.status)));
    };
    xhr.onerror = ()=>{
      resetUploadProgress();
      reject(new Error('network'));
    };
    const form = new FormData();
    form.append('firmware', file);
    xhr.send(form);
  });
}

// BLE: START_UPLOAD:size, chunks, END_UPLOAD
async function uploadOverBle(file){
  if (!ble.ctrl || !ble.data) throw new Error('BLE non connecté');
  const buf = await file.arrayBuffer();
  const u8 = new Uint8Array(buf);

  uploading = true;                 // on signale un upload en cours
  lastUploadPct = -1; setBar(0);
  uplabel.textContent = 'Téléversement en cours...';

  await ble.ctrl.writeValue(new TextEncoder().encode(`START_UPLOAD:${u8.length}`));
  const CHUNK = 200;
  for (let off = 0; off < u8.length; ){
    const slice = u8.subarray(off, Math.min(off+CHUNK, u8.length));
  try { await ble.data.writeValue(slice); }
  catch { await ble.data.writeValueWithResponse(slice); }
    off += slice.length;
    // >>> plus de setUploadProgress ici <<<
  }
  await ble.ctrl.writeValue(new TextEncoder().encode('END_UPLOAD'));
  // on attend EVENT:UPLOAD_COMPLETE depuis le device
}

/* ========= Actions ========= */
inpFile.addEventListener('change', () => {
  if (inpFile.files && inpFile.files[0]) {
    const f = inpFile.files[0];
    nameSpan.textContent = f.name;
    btnUpload.disabled = !/\.bin$/i.test(f.name);
  } else {
    nameSpan.textContent = 'Aucun fichier sélectionné';
    btnUpload.disabled = true;
  }
});

btnUpload.addEventListener('click', async ()=>{
  const f = inpFile.files && inpFile.files[0];
  if (!f){ logln('✖ Aucun fichier'); return; }
  btnUpload.disabled = true; btnOTA.disabled = true;

  try{
    if (transport === 'wifi') {
      await uploadOverWifi(f);
      // Si le firmware n’émet pas EVENT:UPLOAD_COMPLETE en Wi-Fi:
      uplabel.textContent = 'Upload terminé. Prêt pour OTA.';
      setUploadProgress(100);
      btnOTA.disabled = false;
    } else {
      await uploadOverBle(f);
      logln('✔ Téléversement (BLE) envoyé. Attente confirmation device...');
      // Activation OTA à EVENT:UPLOAD_COMPLETE
    }
  } catch(e){
    resetUploadProgress();
    logln('✖ Upload: ' + e.message);
    uplabel.textContent = 'Erreur de téléversement';
    btnUpload.disabled = false;
  }
});

/* ========= Lancer l’OTA (debounce) ========= */
btnOTA.addEventListener('click', async ()=>{
  if (otaSent) { logln('> OTA déjà lancée'); return; }
  otaSent = true; btnOTA.disabled = true;
  lastOtaSeq = -1; lastOtaPct = -1; setBar(0);
  uplabel.textContent = 'Mise à jour en cours...';

  if (transport === 'wifi') {
    if (!ws || ws.readyState !== 1) wsConnect();
    setTimeout(()=> { if (ws && ws.readyState === 1) ws.send('CMD:APPLY_OTA'); }, 200);
  } else {
    await sendOverBle('CMD:APPLY_OTA');
  }
  logln('> CMD:APPLY_OTA envoyé via ' + transport.toUpperCase());
});

/* ========= Divers ========= */
btnReload.addEventListener('click', ()=> location.reload());

/* ========= Init ========= */
window.addEventListener('load', ()=>{
  configureBleAvailability();
  setMode('wifi');      // défaut
  wsConnect();          // logs Wi-Fi dès le départ
});
</script>
</body>
</html>
